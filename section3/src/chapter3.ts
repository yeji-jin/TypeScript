/**
 * 함수 타입의 호환성
 * 특정 함수타입을 다른 함수타입으로 취급해도 괜찮은가를 판단하는것
 * 기준 1. 반환값의 타입이 호환되는가?
 * 기준 2. 매개변수의 타입이 호환되는가?
 * ㄴ 두가지의 조건이 모두 만족되어야 두 함수의 타입이 호환된다 라고 말할 수 있음
 */

// 기준 1. 반환값의 타입이 호환되는가?
type A = () => number; //number
type B = () => 10; //number 리터럴

let a: A = () => 10;
let b: B = () => 10;

a = b; // (O)업캐스팅
// b = a (X) 다운캐스팅

/*
 ✅ a = b; 가 되는 이유
b()는 무조건 10을 반환해 → 숫자 맞지!

a()는 숫자 아무거나 반환하면 돼
→ b는 숫자만 주면 되니까 OK

❌ b = a; 가 안 되는 이유
a()는 10 말고도 20, 30도 줄 수 있어

b()는 꼭 10만 반환해야 해
→ a는 너무 자유로워서 b에 못 넣음
 */

// 기준 2. 매개변수의 타입이 호환되는가?
// 2-1. 매개변수의 개수가 같을 때
type C = (value: number) => void;
type D = (value: 10) => void;

let c: C = (value) => {};
let d: D = (value) => {};

// c = d; (X) C <- D (D타입을 C타입으로 취급 -> number리터럴을 number로) / 업캐스팅
/*
  ❌ c = d가 안 되는 이유
  d는 매개변수로 10만 받을 수 있는 함수
  c는 숫자 전체를 받을 수 있는 함수

  그런데 c = d라는 건 c(5) 같은 코드가 d(5)로 실행된다는 뜻인데, => d(5)는 에러니까 위험
  → 즉, 더 구체적인 매개변수 타입은 더 일반적인 타입에 할당할 수 없음

    ❌ c = d; 가 안 되는 이유
  d(10)은 괜찮은데
  d(5)는 에러야 ❌
  → 그런데 c(5) 이런 식으로 부르면 d(5)가 돼버리니까 위험해

  ✅ d = c; 가 되는 이유
  c는 숫자 아무거나 받을 수 있으니
  d(10) 이렇게 썼을 때, 사실은 c(10) 부르는 거니까 OK!
 */
d = c;
// D <- C (C타입을 D타입으로 취급 -> number를 number리터럴로) / 다운캐스팅
//✅ d = c가 되는 이유
// c는 number를 받으니까 당연히 10도 받을 수 있음
// 즉, d(10)을 호출할 때, 내부적으로 c(10)을 호출하게 되면 문제 없음
// ㄴ 매개변수에서는 일반적인 타입이 구체적인 타입으로 대체 가능

/**
 * why ?
 * 업캐스팅인데 안되는이유는?
 * 반환값타입을 기준으로 호환성을 판단할 때와는 다르게,
 * 매개변수의 타입을 기준으로 호환성을 판단할때는 업캐스팅일경우 호환X / 다운캐스팅 O
 */

// 2-2. 매개변수의 개수가 다를 때
// ㄴ 할당하려는 쪽의 함수의 타입에 매개변수의 개수가 더 적을때 호한가능
type Func1 = (a: number, b: number) => void;
type Func2 = (a: number) => void;

let func1: Func1 = (a, b) => {};
let func2: Func2 = (a) => {};

func1 = func2; // 매개변수개수 2 -> 1
// func2 = func1; (X) 매개변수개수 1 -> 2

/*
🔑 핵심 요약
반환값: 더 구체한 값은 OK (10 → number 가능), 반대는 ❌
매개변수:	더 일반적인 값은 OK (number → 10 가능), 반대는 ❌

“결과값”은 더 자세한 걸 넣어도 돼 (10은 number니까 OK)
“입력값”은 더 자세한 걸 기대하면 위험해 (10만 받는 함수는 위험)
*/
